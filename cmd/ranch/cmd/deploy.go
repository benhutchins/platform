package cmd

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/goodeggs/platform/cmd/ranch/Godeps/_workspace/src/github.com/spf13/cobra"
	"github.com/goodeggs/platform/cmd/ranch/util"
)

var Build bool

type dockerfileTemplateVars struct {
	BuildArgs map[string]string
}

var dockerfileTemplate = template.Must(template.New("dockerfile").Parse(`# generated by ranch
FROM goodeggs/cedar:64621d5
MAINTAINER Good Eggs <open-source@goodeggs.com>

# Build-time Environment
{{ range $name, $process := .BuildArgs }}ARG {{ $name }}
{{ end }}

ENTRYPOINT ["/usr/bin/profile"]

# for web processes
EXPOSE 4443

USER app
ENV HOME /app
WORKDIR /app

COPY . /build

RUN sudo mkdir -p /cache && \
  sudo chown -R app /buildkit /build /cache && \
  /usr/bin/build /build /cache && \
  sudo rm -rf /app && \
  sudo mv /build /app
`))

type composeTemplateVars struct {
	ImageName   string
	Environment map[string]string
	Config      *util.RanchConfig
}

var dockerComposeTemplate = template.Must(template.New("docker-compose").Parse(`# generated by ranch
{{ range $name, $process := .Config.Processes }}
{{ $name }}:
  image: {{ $.ImageName }}
  command: /start {{ $name }}
  volumes:
    - /var/run/docker.sock:/var/run/docker.sock
  {{ if eq $name "web" }}
  ports:
    - 443:4443
  {{ end }}
  environment:
{{ range $k, $v := $.Environment }}{{ printf "    - %s=%s\n" $k $v }}{{ end }}
{{ end }}
`))

var procfileTemplate = template.Must(template.New("procfile").Parse(`# generated by ranch
{{ range $Name, $Process := .Config.Processes }}
{{ $Name }}: {{ $Process.Command }}
{{ end }}
`))

var deployCmd = &cobra.Command{
	Use:   "deploy",
	Short: "Deploy the application",
	RunE: func(cmd *cobra.Command, args []string) (err error) {

		appDir, err := util.AppDir(cmd)
		if err != nil {
			return err
		}

		clean, err := util.GitIsClean(appDir)
		if err != nil {
			return err
		}

		if !clean {
			return fmt.Errorf("git working directory not clean.")
		}

		appName, err := util.AppName(cmd)
		if err != nil {
			return err
		}

		config, err := util.LoadAppConfig(cmd)
		if err != nil {
			return err
		}

		appVersion, err := util.AppVersion(cmd)
		if err != nil {
			return err
		}

		exists, err := util.EcruReleaseExists(appName, appVersion)
		if err != nil {
			return err
		}

		if exists {
			return fmt.Errorf("release %s already exists.", appVersion)
		}

		imageName := strings.Join([]string{appName, appVersion}, ":")

		if Build {
			if err = dockerBuildAndPush(appDir, imageName, config); err != nil {
				return err
			}
		} else {
			fmt.Println("skipping Docker build & push")
		}

		buildDir, err := ioutil.TempDir("", "ranch")
		if err != nil {
			return err
		}

		fmt.Println("using build directory", buildDir)

		var env map[string]string
		if config.EnvId != "" {
			plaintext, err := util.EcruGetSecret(appName, config.EnvId)
			if err != nil {
				return err
			}

			env, err = util.ParseEnv(plaintext)
			if err != nil {
				return err
			}
		}

		if err = generateDockerCompose(imageName, config, env, buildDir); err != nil {
			return err
		}

		if err = convoxDeploy(appName, appVersion, buildDir); err != nil {
			return err
		}

		if err = util.ConvoxScale(appName, config); err != nil {
			return err
		}

		return nil
	},
}

func init() {
	deployCmd.Flags().BoolVar(&Build, "build", true, "Build and push the Docker image")
	RootCmd.AddCommand(deployCmd)
}

func convoxDeploy(appName, appVersion, buildDir string) error {
	releaseId, err := util.ConvoxDeploy(appName, buildDir)

	if err != nil {
		return err
	}

	if err = util.EcruCreateRelease(appName, appVersion, releaseId); err != nil {
		return err
	}

	fmt.Printf("promoting release %s\n", appVersion)

	if err = util.ConvoxPromote(appName, appVersion); err != nil {
		return err
	}

	if err = util.ConvoxWaitForStatus(appName, "running"); err != nil {
		return err
	}

	return nil
}

func generateDockerCompose(imageName string, config *util.RanchConfig, env map[string]string, buildDir string) error {
	var out bytes.Buffer

	absoluteImageName, err := util.DockerResolveImageName(imageName)

	if err != nil {
		return err
	}

	err = dockerComposeTemplate.Execute(&out, composeTemplateVars{
		ImageName:   absoluteImageName,
		Environment: env,
		Config:      config,
	})

	if err != nil {
		return err
	}

	dockerCompose := path.Join(buildDir, "docker-compose.yml")
	err = ioutil.WriteFile(dockerCompose, out.Bytes(), 0644)

	if err != nil {
		return err
	}

	return nil
}

func dockerBuildAndPush(appDir, imageName string, config *util.RanchConfig) (err error) {

	env, err := util.EnvGet(config.Name, config.EnvId)

	if err != nil {
		return err
	}

	dockerfile := path.Join(appDir, "Dockerfile")

	if _, err := os.Stat(dockerfile); os.IsNotExist(err) {

		var out bytes.Buffer
		err = dockerfileTemplate.Execute(&out, dockerfileTemplateVars{
			BuildArgs: env,
		})

		if err != nil {
			return err
		}

		err = ioutil.WriteFile(dockerfile, out.Bytes(), 0644)

		if err != nil {
			return err
		}

		defer os.Remove(dockerfile) // cleanup
	} else {
		fmt.Println("WARNING: using existing Dockerfile")
	}

	procfile := path.Join(appDir, "Procfile")

	if _, err := os.Stat(procfile); os.IsNotExist(err) {
		var out bytes.Buffer
		err = procfileTemplate.Execute(&out, composeTemplateVars{
			ImageName: imageName,
			Config:    config,
		})

		if err != nil {
			return err
		}

		err = ioutil.WriteFile(procfile, out.Bytes(), 0644)

		if err != nil {
			return err
		}

		defer os.Remove(procfile) // cleanup
	} else {
		fmt.Println("WARNING: using existing Procfile")
	}

	err = util.DockerBuild(appDir, imageName, env)

	if err != nil {
		return err
	}

	err = util.DockerPush(imageName)

	if err != nil {
		return err
	}

	return nil
}
