package cmd

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/goodeggs/platform/cmd/ranch/Godeps/_workspace/src/github.com/spf13/cobra"
	"github.com/goodeggs/platform/cmd/ranch/util"
)

var Build bool

type dockerfileTemplateVars struct {
	BuildArgs map[string]string
}

var dockerfileTemplate = template.Must(template.New("dockerfile").Parse(`# generated by ranch
FROM goodeggs/cedar:bebd701
MAINTAINER Good Eggs <open-source@goodeggs.com>
# everything else handled by goodeggs/cedar ONBUILD commands
# see https://github.com/goodeggs/cedar

# Build-time Environment
{{ range $name, $process := .BuildArgs }}ARG {{ $name }}
{{ end }}
`))

type composeTemplateVars struct {
	ImageName   string
	Environment map[string]string
	Config      *util.RanchConfig
}

var dockerComposeTemplate = template.Must(template.New("docker-compose").Parse(`# generated by ranch
{{ range $name, $process := .Config.Processes }}
{{ $name }}:
  image: {{ $.ImageName }}
  command: /start {{ $name }}
  volumes:
    - /var/run/docker.sock:/var/run/docker.sock
  {{ if eq $name "web" }}
  ports:
    - 443:4443
  {{ end }}
  environment:
{{ range $k, $v := $.Environment }}{{ printf "    - %s=%s\n" $k $v }}{{ end }}
{{ end }}
`))

var procfileTemplate = template.Must(template.New("procfile").Parse(`# generated by ranch
{{ range $Name, $Process := .Config.Processes }}
{{ $Name }}: {{ $Process.Command }}
{{ end }}
`))

var deployCmd = &cobra.Command{
	Use:   "deploy",
	Short: "Deploy the application",
	Run: func(cmd *cobra.Command, args []string) {

		appDir, err := util.AppDir(cmd)
		util.Check(err)

		clean, err := util.GitIsClean(appDir)
		util.Check(err)

		if !clean {
			util.Die("git working directory not clean.")
		}

		appName, err := util.AppName(cmd)
		util.Check(err)

		config, err := util.LoadAppConfig(cmd)
		util.Check(err)

		appVersion, err := util.AppVersion(cmd)
		util.Check(err)

		exists, err := util.EcruReleaseExists(appName, appVersion)
		util.Check(err)
		if exists {
			util.Die(fmt.Sprintf("release %s already exists.", appVersion))
		}

		imageName := strings.Join([]string{appName, appVersion}, ":")

		if Build {
			err = dockerBuildAndPush(appDir, imageName, config)
			util.Check(err)
		} else {
			fmt.Println("skipping Docker build & push")
		}

		buildDir, err := ioutil.TempDir("", "ranch")
		util.Check(err)

		fmt.Println("using build directory", buildDir)

		var env map[string]string
		if config.EnvId != "" {
			plaintext, err := util.EcruGetSecret(appName, config.EnvId)
			util.Check(err)

			env, err = util.ParseEnv(plaintext)
			util.Check(err)
		}

		err = generateDockerCompose(imageName, config, env, buildDir)
		util.Check(err)

		err = convoxDeploy(appName, appVersion, buildDir)
		util.Check(err)

		err = util.ConvoxScale(appName, config)
		util.Check(err)

	},
}

func init() {
	deployCmd.Flags().BoolVar(&Build, "build", true, "Build and push the Docker image")
	RootCmd.AddCommand(deployCmd)
}

func convoxDeploy(appName, appVersion, buildDir string) error {
	releaseId, err := util.ConvoxDeploy(appName, buildDir)

	if err != nil {
		return err
	}

	if err = util.EcruCreateRelease(appName, appVersion, releaseId); err != nil {
		return err
	}

	fmt.Printf("promoting release %s\n", appVersion)

	if err = util.ConvoxPromote(appName, appVersion); err != nil {
		return err
	}

	if err = util.ConvoxWaitForStatus(appName, "running"); err != nil {
		return err
	}

	return nil
}

func generateDockerCompose(imageName string, config *util.RanchConfig, env map[string]string, buildDir string) error {
	var out bytes.Buffer

	absoluteImageName, err := util.DockerResolveImageName(imageName)

	if err != nil {
		return err
	}

	err = dockerComposeTemplate.Execute(&out, composeTemplateVars{
		ImageName:   absoluteImageName,
		Environment: env,
		Config:      config,
	})

	if err != nil {
		return err
	}

	dockerCompose := path.Join(buildDir, "docker-compose.yml")
	err = ioutil.WriteFile(dockerCompose, out.Bytes(), 0644)

	if err != nil {
		return err
	}

	return nil
}

func dockerBuildAndPush(appDir, imageName string, config *util.RanchConfig) error {
	var err error

	dockerfile := path.Join(appDir, "Dockerfile")

	if _, err := os.Stat(dockerfile); os.IsNotExist(err) {
		buildArgs := make(map[string]string)
		for _, item := range os.Environ() {
			parts := strings.SplitN(item, "=", 2)
			if len(parts) == 2 {
				buildArgs[parts[0]] = parts[1]
			}
		}

		var out bytes.Buffer
		err = dockerfileTemplate.Execute(&out, dockerfileTemplateVars{
			BuildArgs: buildArgs,
		})

		if err != nil {
			return err
		}

		err = ioutil.WriteFile(dockerfile, out.Bytes(), 0644)

		if err != nil {
			return err
		}

		defer os.Remove(dockerfile) // cleanup
	} else {
		fmt.Println("WARNING: using existing Dockerfile")
	}

	procfile := path.Join(appDir, "Procfile")

	if _, err := os.Stat(procfile); os.IsNotExist(err) {
		var out bytes.Buffer
		err = procfileTemplate.Execute(&out, composeTemplateVars{
			ImageName: imageName,
			Config:    config,
		})

		if err != nil {
			return err
		}

		err = ioutil.WriteFile(procfile, out.Bytes(), 0644)

		if err != nil {
			return err
		}

		defer os.Remove(procfile) // cleanup
	} else {
		fmt.Println("WARNING: using existing Procfile")
	}

	err = util.DockerBuild(appDir, imageName)

	if err != nil {
		return err
	}

	err = util.DockerPush(imageName)

	if err != nil {
		return err
	}

	return nil
}
